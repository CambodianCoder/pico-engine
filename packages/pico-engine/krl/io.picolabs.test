/* Rules with a public facing point of entry are camelCase, internal rules are snake_case*/
ruleset io.picolabs.test {
  meta {
    shares __testing, test, getFullReport, getTestsOverview
    use module io.picolabs.wrangler alias wrangler
  }
  global {
    __testing = { "queries":
      [ { "name": "__testing" }
      , { "name": "test", "args": [] }
      , { "name": "getFullReport", "args": [] }
      , { "name": "getTestsOverview", "args": [] }
      ] , "events":
      [ { "domain": "tests", "type": "run_tests"},
        { "domain": "tests", "type": "unregister_ruleset", "attrs":["rid_to_remove"]}
      //, { "domain": "d2", "type": "t2", "attrs": [ "a1", "a2" ] }
      ]
    }
      
      // dont forget to schedule timeout for all tests
    
      //generateTestStartRule(tests{"Pico Creation"})
      // ent:register_response;
      // ent:unregister_response
      // tests{["Pico Creation", "listeners", "wrangler:child_initialized", "expressions"]}[0][1].klog("under test").typeof();
    
    test = function() {
      // parsedMap = 
      // {
      //   "key1":"value1",
      //   "key2":"value2",
      //   "key3":"value3",
      //   "key4":{"innerKey":"hello"}
      // };
      
      // //indexing with and without hash path works
      // usedToIndex = parsedMap{<<key1>>};
      // usedToIndex2 = parsedMap{[<<key4>>, <<innerKey>>]};
      
      // // can use .put
      // usingPut = parsedMap.put(<<key5>>, "changed");
      
      // //cant use in literal as a key
      // parseError =
      // {
      //   "key1":<<value1>>,
      //   "key2":"value2",
      //   <<key3>>:"value3" // parse error 
      // };
      // usingPut
      ent:test_report
    }
    
    
    
    getNumOfTests = function(tests) {
      tests
      .values().klog("test vals")
      .reduce(function(num, test_b){
        numTestsInB = test_b{"listeners"}
                      .keys()
                      .reduce(function(num, listener_b){
                        num + test_b{["listeners",listener_b.klog("listener_b"), "expressions"]}.klog("expressions").length()  
                      },0);
        num + numTestsInB.klog("number tests found in listener")
      }, 0);
    }
    
    getFailedTests = function() {
      ent:test_report.map(function(listeners, testName) {
                                listeners.values().klog("values")
                                         .map(function(exprs, event){
                                              exprs.filter(function(testStatus, expr){
                                                      testStatus == "failed" || testStatus == "pending" || testStatus == "tried_to_run"
                                                   })
                                                  // .map(function(expr, testStatus){ // add descriptions
                                                  //     ent:tests_to_run{[testName, ]
                                                  // })
                                         })
                     });
    }
    
    getTestsOverview = function() {
      numTestsToRun = getNumOfTests(ent:tests_to_run);
      numTestsHaveRun = ent:test_report.values()
                                       .reduce(function(numTests, listeners){
                                            numTests + listeners.values()
                                                                .reduce(function(num, listener){
                                                                    num + listener.values().length()
                                                                }, 0)
                                       }, 0);
      percentComplete = numTestsToRun == 0 => 100 | numTestsHaveRun.klog("has run")/numTestsToRun.klog("to run") * 100;
      hasTimedOut = ent:tests_timed_out.defaultsTo(false);
      failedTests = hasTimedOut || percentComplete >= 100 => getFailedTests() | null;
      overviewMap = {
        "percentComplete":percentComplete,
        "timedOut":hasTimedOut
      };
      
      failedTests =>
      overviewMap.put("failedTests", failedTests) |
      overviewMap
    }
    
    getFullReport = function() {
      ent:test_report
    }
    
    rulesetUnderTest = "io.picolabs.wrangler"
    
    tests = {
      "Pico Creation": {
        "kickoff_events": {
          "wrangler:new_child_request":{"name":"blue"}
        },
        "start_state": <<>>,
        "listeners": {
          "wrangler:child_initialized" : {
             "expressions": [
                ["Child name should exist", <<not wrangler:children(event:attrs{"name"})>>]
               ,["Pico should only have one child", <<wrangler:children().length() == 1>>]
               ,["Child name should be blue", <<wrangler:children().any(function(child){child{"name"} == "red"})>>]
              ]
          }
        },
        "meta": [
          "use module io.picolabs.wrangler alias wrangler"
        ],
        "global":[]
      }
    }
    
    testRid = function(testName) {
      meta:rid + "." + rulesetUnderTest + "." + testName.replace(re# #, "");
    }
    
    generateRuleset = function(test, testName) {
      rid = testRid(testName);
      metaBlock = generateMetaBlock(test{"meta"}.klog("meta passing")).klog("generated meta block");
      globalBlock = generateGlobalBlock(test{"global"});
      rules = generateRules(test, testName);
      "ruleset " + rid + "{" + metaBlock + globalBlock + rules + "}"
    }
    
    generateRules = function(test, testName) {
      testStartRule = generateTestStartRule(test);
      testRules = test{"listeners"}.map(function(listener, listenerName){
        generateTestRule(listener, listenerName)
      }).values().join(" ");
      testCompletionCheckRule = generateTestCompletionCheckRule(testName);
      <<
        #{testStartRule}
        #{testRules}
        #{testCompletionCheckRule}
      >>
    }
    
    generateMetaBlock = function(metaStrings) {
      metaString = metaStrings.join(" ").defaultsTo("").klog("joined array");
      "meta{" + metaString +"}"
    }
    
    generateGlobalBlock = function(globalStrings) {
      globalString = globalStrings.join("\n").defaultsTo("");
      areTestsCompleteFn = 
        <<areTestsComplete = function() {
          ent:running_tests.map(function(expressions, event) {
            expressions.map(function(testStatus, testExpr) {
              testStatus == "failed" || testStatus == "passed" || testStatus == "tried_to_run"
            }).values().all(function(testAttempted) {testAttempted})
          })
          .values()
          .all(function(testAttempted) {testAttempted})
        }>>;
        
      <<global{ 
        #{globalString}
        #{areTestsCompleteFn}  
        }>>
    }
    
    /*
      rule testStart
        w test_ruleset installed
        -> create entity var to hold test progress
        -> raise kickoff events w their attributes
        -> schedule a timeout for if any tests hard fail
    */
    generateTestStartRule = function(test) {
      testEntityVar = function(listeners) {
        listenersToTest = listeners.map(function(properties,listener) {
          exprStatusMap = "{}" + properties{"expressions"}.map(function(exp_arr){<<.put(<<#{exp_arr[1]}\>\>, "pending")>>}).join("");
        <<"#{listener}" : #{exprStatusMap}>>
        }).values().join(",");
        "ent:running_tests := {"+ listenersToTest +"};
        "
      };
      
      raisedEvents = test{"kickoff_events"}.map(function(event_attrs, event){
        domain_and_event = event.split(re#:#);
        <<raise #{domain_and_event[0]} event "#{domain_and_event[1]}" attributes {}.put(#{event_attrs.encode()})>>
      }).values();
      
      scheduledTimeout = << schedule test event "test_timed_out" 
                              at time:add(time:now(), ent:default_timeout.defaultsTo({"seconds":45}))
                              attributes event:attrs
                              setting(scheduled_timeout);
                            ent:scheduled_timeout_event := scheduled_timeout >>;
                            
      <<rule testStart { 
        select when wrangler ruleset_added where rids >< "#{rulesetUnderTest}" 
          always{ 
            #{testEntityVar(test{"listeners"})} 
            #{raisedEvents.join(";
            ")} 
            
          } 
        }>> // rule end
    }
    
    /*
      rule test_rule_<UUID>
        w listener event
        -> set ent:running_tests "tried to run" for relevant expressions
        -> raise event if expr_sucess
        -> raise event if expr_failed
    */
    generateTestRule = function(listener, listenerName) {
      domain_and_event = listenerName.split(re#:#);
      domain = domain_and_event[0];
      event = domain_and_event[1];
      
      testExprs = function(expressions) {
        expressions.map(function(exprPair){
            expression = exprPair[1];
            exprDescription = exprPair[0];
            attrs = <<event:attrs.put("test_description", <<#{exprDescription}\>\>).put("test_listener", <<#{listenerName}\>\>)>>;
            <<ent:running_tests{["#{listenerName}", <<#{expression}\>\>]} := "passed" if #{expression};
              ent:running_tests{["#{listenerName}", <<#{expression}\>\>]} := "failed" if not (#{expression});>>
        }).join("
        ")
      };
      
      <<rule test_rule_#{random:uuid()} {
        select when #{domain} #{event}
        always {
          ent:running_tests{"#{listenerName}"} := ent:running_tests{"#{listenerName}"}
                                                                 .map(function(status,expr) {
                                                                    "tried_to_run"
                                                                 });
         raise test event "test_ran" attributes event:attrs;
         #{testExprs(listener{"expressions"})}
        }
      } >>
    }
    
    /*
    rule are_tests_done
      w expression success or expression failure or tests_timed_out
      -> unschedule timeout
      -> send test result back
    */
    generateTestCompletionCheckRule = function(testName) {

      
      <<rule are_tests_done {
        select when test test_ran or
                    test test_timed_out
        if areTestsComplete() || event:type() == "test_timed_out" then
          event:send({"eci":wrangler:parent_eci(), "domain":"test", "type":"test_report", "attrs": {"testName" : <<#{testName}\>\>, "report":ent:running_tests}})
        always {
          ent:tests_completed := true
        }
        } >>// end rule
    }
    
    
  }
  
  /**
   * tests = [
     randomPicoName: {
       randomPicoName should return a random english word if children <= 200: true // true means passed, fail means test failed
       randomPicoName should return a UUID if children > 200: true
     }
     new_child_request: {
       New child should be created: false
       ...
     }
     ...
   ]
   * tests = [
      randomPicoName: {
        kickoff_events: [
          "wrangler:new_child_request"
        ]
        listeners: [
          "wrangler:child_initialized" : {
           expressions: [
              "children(event:attrs{"name"})"
              "children().length() == 1"
           ]
            
          }
        ]
      }
    ]
   * 
   */
   
  // rule record_test_result {
  //   select when tests record_result
  //   pre {
  //     testsName = event:attrs{
  //   }
  //   always {
  //     ent:test_report{
  //   }
  // }
   
  rule runTests {
    select when tests run_tests
    pre {
      tests_to_run = event:attr("tests") || tests
    }
    //if not ent:tests_to_run then
    noop()
    fired {
      //ent:tests_to_run := tests_to_run;
      raise tests event "run_each_test" attributes event:attrs.put({
        "tests":tests.keys()
      })
    }
  }
  
  rule run_each_test {
    select when tests run_each_test
    foreach event:attr("tests") setting (testName)
    pre {
      test = ent:tests_to_run{testName}
      krlCode = generateRuleset(test, testName)
      rid = testRid(testName)
    }
    // a bit of a hack. 
    http:post(meta:host + "/api/ruleset/register",
              form = {
                "src": krlCode
              }) setting (register_response)
    always {
      register_response.klog("ruleset register response");
      ent:register_response := register_response;
      raise test event "unable_to_create_test_ruleset" attributes event:attrs.put("test_with_problem", test) if register_response{"status_code"} != 200;
      raise wrangler event "new_child_request" attributes event:attrs.put({
        "rids":[rulesetUnderTest, rid],
        "name":rid
      }) if register_response{"status_code"} == 200
    }
  }
  
  rule receive_test_report {
    select when test test_report
    pre {
      picoReport = event:attrs
      testName = event:attrs{"testName"}
      testReport = event:attrs{"report"}
    }
    always {
      ent:test_report{[testName]} := testReport;
      raise wrangler event "child_deletion" attributes {
        "name":testRid(testName),
        //"co_id":meta:rid,
        "rid":testRid(testName)
      }
    }
  }
  
  rule delete_rid_after_child_deleted {
    select when wrangler child_deleted
    pre {
      completedTestRid = event:attrs{"rid"}
    }
    if completedTestRid then
    noop()
    fired {
      raise tests event "unregister_ruleset" attributes event:attrs.put("rid_to_remove", completedTestRid)
    }
  }
  
  
  
  rule unregister_test_ruleset {
    select when tests unregister_ruleset
    pre {
      rid_to_remove = event:attrs{"rid_to_remove"}.klog("trying to remove rid")
    }
    http:get(meta:host + "/api/ruleset/unregister/" + rid_to_remove) setting(unregister_response)
    always {
      ent:unregister_response := unregister_response
    }
  }
}
