/* Rules with a public facing point of entry are camelCase, internal rules are snake_case*/
ruleset io.picolabs.test {
  meta {
    shares __testing, test
    use module io.picolabs.wrangler alias wrangler
  }
  global {
    __testing = { "queries":
      [ { "name": "__testing" }
      , { "name": "test", "args": [] }
      ] , "events":
      [ { "domain": "tests", "type": "run_tests"},
        { "domain": "tests", "type": "unregister_ruleset"}
      //, { "domain": "d2", "type": "t2", "attrs": [ "a1", "a2" ] }
      ]
    }
    
    
      //generateTestStartRule(tests{"Pico Creation"})
      // ent:register_response;
      // ent:unregister_response
      // tests{["Pico Creation", "listeners", "wrangler:child_initialized", "expressions"]}[0][1].klog("under test").typeof();
    
    test = function() {
      // parsedMap = 
      // {
      //   "key1":"value1",
      //   "key2":"value2",
      //   "key3":"value3",
      //   "key4":{"innerKey":"hello"}
      // };
      
      // //indexing with and without hash path works
      // usedToIndex = parsedMap{<<key1>>};
      // usedToIndex2 = parsedMap{[<<key4>>, <<innerKey>>]};
      
      // // can use .put
      // usingPut = parsedMap.put(<<key5>>, "changed");
      
      // //cant use in literal as a key
      // parseError =
      // {
      //   "key1":<<value1>>,
      //   "key2":"value2",
      //   <<key3>>:"value3" // parse error 
      // };
      // usingPut
      0
    }
    
    getTestProgress = function() {
      
    }
    
    rulesetUnderTest = "io.picolabs.wrangler"
    
    tests = {
      "Pico Creation": {
        "kickoff_events": {
          "wrangler:new_child_request":{"name":"blue"}
        },
        "listeners": {
          "wrangler:child_initialized" : {
             "expressions": [
                ["Child name should exist", <<wrangler:children(event:attrs{"name"})>>]
               ,["Pico should only have one child", <<wrangler:children().length() == 1>>]
               ,["Child name should be blue", <<wrangler:children().any(function(child){child{"name"} == "blue"}>>]
              ]
          }
        },
        "meta": [
          "use module io.picolabs.wrangler alias wrangler"
        ],
        "global":[]
      }
    }
    
    testRid = function(testName) {
      meta:rid + "." + testName.replace(re# #, "");
    }
    
    generateRuleset = function(test, testName) {
      rid = testRid(testName);
      metaBlock = generateMetaBlock(test{"meta"}.klog("meta passing")).klog("generated meta block");
      globalBlock = generateGlobalBlock(test{"global"});
      rules = generateRules(test);
      "ruleset " + rid + "{" + metaBlock + globalBlock + rules + "}"
    }
    
    generateRules = function(test) {
      testStartRule = generateTestStartRule(test);
      testRules = test{"listeners"}.map(function(listener, listenerName){
        generateTestRule(listener, listenerName)
      }).values().join("\n\n");
      testCompletionCheckRule = generateTestCompletionCheckRule();
      <<
        #{testStartRule}
        #{testRules}
        #{testCompletionCheckRule}
      >>
    }
    
    generateMetaBlock = function(metaStrings) {
      metaString = metaStrings.join("\n").defaultsTo("").klog("joined array");
      "meta{" + metaString +"}"
    }
    
    generateGlobalBlock = function(globalStrings) {
      globalString = globalStrings.join("\n").defaultsTo("");
      areTestsCompleteFn = 
        <<areTestsComplete = function() {
          ent:running_tests.map(function(event, expressions) {
            expressions.map(function(testStatus, testExpr) {
              testStatus == "failed" || testStatus == "passed" || testStatus == "tried_to_run"
            }).values().all(function(testAttempted) {testAttempted})
          })
          .values()
          .all(function(testAttempted) {testAttempted})
        }>>;
        
      <<global{ 
        #{globalString}
        #{areTestsCompleteFn}  
        }>>
    }
    
    /*
      rule testStart
        w test_ruleset installed
        -> create entity var to hold test progress
        -> raise kickoff events w their attributes
        -> schedule a timeout for if any tests hard fail
    */
    generateTestStartRule = function(test) {
      testEntityVar = function(listeners) {
        listenersToTest = listeners.map(function(properties,listener) {
          exprStatusMap = properties{"expressions"}.map(function(exp_arr){<< <<#{exp_arr[1]}\>\> :"pending",>>}).join("\n");
        <<"#{listener}" : { #{exprStatusMap} },>>
        }).values().join("");
        "ent:running_tests := {"+ listenersToTest +"};\n"
      };
      
      raisedEvents = test{"kickoff_events"}.map(function(event_attrs, event){
        domain_and_event = event.split(re#:#);
        <<raise #{domain_and_event[0]} event "#{domain_and_event[1]}" attributes event:attrs.put(#{event_attrs.encode()})>>
      }).values();
      
      scheduledTimeout = << schedule test event "test_timed_out" 
                              at time:add(time:now(), ent:default_timeout.defaultsTo({"seconds":45}))
                              attributes event:attrs
                              setting(scheduled_timeout);
                            ent:scheduled_timeout_event := scheduled_timeout >>;
                            
      <<rule testStart { 
        select when wrangler ruleset_added where rids >< "#{rulesetUnderTest}" 
          always{ 
            #{testEntityVar(test{"listeners"})} 
            #{raisedEvents.join(";\n")} 
            
          } 
        }>> // rule end
    }
    
    /*
      rule test_rule_<UUID>
        w listener event
        -> set ent:running_tests "tried to run" for relevant expressions
        -> raise event if expr_sucess
        -> raise event if expr_failed
    */
    generateTestRule = function(listener, listenerName) {
      domain_and_event = listenerName.split(re#:#);
      domain = domain_and_event[0];
      event = domain_and_event[1];
      
      raisedEvents = function(expressions) {
        expressions.map(function(exprPair){
            expression = exprPair[1];
            exprDescription = exprPair[0];
            attrs = <<event:attrs.put("test_description", #{exprDescription}).put("test_listener", #{listenerName})>>;
            <<raise event test expression_success attributes #{attrs} if #{expression};
              raise event test expression_failure attributes #{attrs} if not (#{expression});>>
        }).join("\n")
      };
      
      <<rule test_rule_#{random:uuid()} {
        select when #{domain} #{event}
        always {
          ent:running_tests{#{listenerName}} := ent:running_tests{#{listenerName}}
                                                                 .map(function(status,expr) {
                                                                    "tried_to_run"
                                                                 });
         #{raisedEvents(listener{"expressions"})}
        }
      } >>
    }
    
    /*
    rule are_tests_done
      w expression success or expression failure or tests_timed_out
      -> unschedule timeout
      -> send test result back
    */
    generateTestCompletionCheckRule = function() {

      
      <<rule are_tests_done {
        select when test expression_success or
                    test expression_failure or
                    test test_timed_out
        if areTestsComplete() || event:type() == "test_timed_out" then
          event:send({"eci":wrangler:parent_eci(), "domain":"test", "type":"test_report", "attrs": ent:running_tests})
        always {
          ent:tests_completed := true
        }
        } >>// end rule
    }
    
    
  }
  
  /**
   * tests = [
     randomPicoName: {
       randomPicoName should return a random english word if children <= 200: true // true means passed, fail means test failed
       randomPicoName should return a UUID if children > 200: true
     }
     new_child_request: {
       New child should be created: false
       ...
     }
     ...
   ]
   * tests = [
      randomPicoName: {
        kickoff_events: [
          "wrangler:new_child_request"
        ]
        listeners: [
          "wrangler:child_initialized" : {
           expressions: [
              "children(event:attrs{"name"})"
              "children().length() == 1"
           ]
            
          }
        ]
      }
    ]
   * 
   */
   
   rule record_test_result {
     select when tests record_result
     
   }
   
  rule runTests {
    select when tests run_tests
    pre {
      tests_to_run = event:attr("tests") || tests
    }
    always {
      ent:tests_to_run := tests_to_run;
      raise tests event "run_each_test" attributes event:attrs.put({
        "tests":tests.keys()
        })
    }
  }
  
  rule run_each_test {
    select when tests run_each_test
    foreach event:attr("tests") setting (testName)
    pre {
      test = ent:tests_to_run{testName}
      krlCode = generateRuleset(test, testName)
      rid = testRid(testName)
    }
    // a bit of a hack. 
    http:post(meta:host + "/api/ruleset/register",
              form = {
                "src": krlCode
              }) setting (register_response)
    always {
      register_response.klog("ruleset register response");
      ent:register_response := register_response;
      raise wrangler event "new_child_request" attributes event:attrs.put({
        "rids":[rulesetUnderTest, rid],
        "name":rid
      })
    }
  }
  
  rule receive_test_report {
    select when test test_report
    pre {
      
    }
  }
  
  
  
  rule unregister_test_ruleset {
    select when tests unregister_ruleset
    pre {
      rid_to_remove = "io.picolabs.test.PicoCreation"
    }
    http:get(meta:host + "/api/ruleset/unregister/" + rid_to_remove) setting(unregister_response)
    always {
      ent:unregister_response := unregister_response
    }
  }
}
